/*
 * generated by Xtext 2.17.0
 */
package org.hanashiconlang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.hanashiconlang.hanashi.Article
import java.util.Map
import java.util.Collection
import java.util.HashMap
import org.hanashiconlang.hanashi.Taxon
import java.util.ArrayList
import org.hanashiconlang.hanashi.Morpheme

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HanashiGenerator extends AbstractGenerator {
	
//	
//	dispatch def IntStream getTerminals(Terminal prod) {
//		prod.text.codePoints
//	}
//	dispatch def IntStream getTerminals(NonTerminal prod) {
//		getTerminals(prod.target.production)
//	}
//	dispatch def IntStream getTerminals(Weighted prod) {
//		IntStream.empty
//	}
//	dispatch def IntStream getTerminals(Optional prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Repeated prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Choice prod) {
//		getTerminals(prod.left).concat(getTerminals(prod.right))
//	}
//	dispatch def IntStream getTerminals(Sequence prod) {
//		prod.seq.map[p| getTerminals(p) ].stream().flatMap[s| s.boxed() ].mapToInt[v| v]
//	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		var morphemesByTaxon = new HashMap<Taxon, ArrayList<Morpheme>>()
		for (m : resource.allContents.filter(Morpheme).toIterable)
			for (t : m.taxons) {
				if (!morphemesByTaxon.containsKey(t.target))
					morphemesByTaxon.put(t.target, new ArrayList())
				morphemesByTaxon.get(t.target).add(m)
			}
		
		val baseName = resource.URI.trimFileExtension.lastSegment
		for (article : resource.allContents.filter(Article).toIterable) 
			for (lang : article.languages) {
				val renderer = new HanashiRenderer(lang, morphemesByTaxon) 
				fsa.generateFile(baseName + "." + article.name + '.' + lang.name + '.html', '''
					<html>
					<head>
					<title>
					«renderer.generateRichString(article.title, false)»
					</title>
					<style>
					a:link { text-decoration: none; }
					a:hover { text-decoration: underline; }
					table.gloss { border: 0; display: inline-table; margin-left: 1em; margin-right: 1em; padding: 0; }
					.gloss-info { font-size:66%; line-height:20%; }
					body { width: 50em; text-align: justify; margin-left: auto; margin-right: auto }
					rtc.gloss-info { ruby-position: under; ruby-align: center; }
					</style>
					</head>
					<body>
					«FOR p: article.parts»
 					    «renderer.generatePart(p, 1)»
					«ENDFOR»
                    «FOR p: article.appendix BEFORE "<h1>Appendix</h1>"»
                        «renderer.generatePart(p, 2)»
                    «ENDFOR»
					</body>
					</html>
				''')
			}
		
	}

}

