/*
 * generated by Xtext 2.17.0
 */
package org.hanashiconlang.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.scoping.IScopeProvider
import org.hanashiconlang.hanashi.Article
import org.hanashiconlang.hanashi.PartLexicon
import org.hanashiconlang.hanashi.PartSection
import org.hanashiconlang.hanashi.PartTaxonomy
import org.hanashiconlang.hanashi.PartTOC
import org.eclipse.xtext.util.Tuples
import org.eclipse.xtext.util.Pair

interface HanashiFunction {
    def String validate(Iterable<CharSequence> text) { 
    	null
    }
    def CharSequence generate(Iterable<CharSequence> text)
    def CharSequence string(Iterable<CharSequence> text)
}
abstract class NoArgumentFunction implements HanashiFunction {
    val String name
    new(String name) {
        this.name = name
    }
    override validate(Iterable<CharSequence> text) {
        if (text.size != 0)
            "'" + name + "' takes no arguments"
        else
            null 
    }
    override generate(Iterable<CharSequence> text) {
        doGenerate()
    }
    override string(Iterable<CharSequence> text) {
        doString()
    }
    abstract def CharSequence doGenerate()
    abstract def CharSequence doString()
}
abstract class OneArgumentFunction implements HanashiFunction {
    val String name
    new(String name) {
        this.name = name
    }
    override validate(Iterable<CharSequence> text) {
        if (text.size != 1)
            "'" + name + "' requires exactly one argument"
        else
            null 
    }
    override generate(Iterable<CharSequence> text) {
        doGenerate(text.head)
    }
    override string(Iterable<CharSequence> text) {
        doString(text.head)
    }
    abstract def CharSequence doGenerate(CharSequence text)
    abstract def CharSequence doString(CharSequence text)
}
class SurroundFunction extends OneArgumentFunction {
    val String before
    val String after
    new(String name, String before, String after) {
        super(name)
        this.before = before
        this.after = after
    }
    override doGenerate(CharSequence text) 
        '''«before»«text»«after»'''
    override doString(CharSequence text) {
        '''«before»«text»«after»'''
    }
}
class SurroundMarkupFunction extends SurroundFunction {
    new(String name, String before, String after) {
        super(name, before, after)
    }
    override doString(CharSequence text) {
        '''«text»'''
    }
}
abstract class PairArgumentsFunction implements HanashiFunction {
    val String name
    new(String name) {
        this.name = name
    }
    override validate(Iterable<CharSequence> text) {
        if (text.size % 2 != 0)
            "'" + name + "' requires an even number of arguments"
        else
            null  
    }
    override generate(Iterable<CharSequence> text) {
        val pairs = <Pair<CharSequence, CharSequence>>newArrayOfSize(text.size / 2)
        val it = text.iterator
        var i = 0
        while (it.hasNext) {
            pairs.set(i, Tuples.create(it.next, it.next))
            i += 1
        }
        doGenerate(pairs.toList)
    }
    override string(Iterable<CharSequence> text) {
        val pairs = <Pair<CharSequence, CharSequence>>newArrayOfSize(text.size / 2)
        val it = text.iterator
        var i = 0
        while (it.hasNext) {
            pairs.set(i, Tuples.create(it.next, it.next))
            i += 1
        }
        doString(pairs)
    }
    abstract def CharSequence doGenerate(Iterable<Pair<CharSequence, CharSequence>> text)
    abstract def CharSequence doString(Iterable<Pair<CharSequence, CharSequence>> text)
}
class HanashiFunctions {
    public static val p = new SurroundMarkupFunction("p", "<p>", "</p>")
    public static val h = new PairArgumentsFunction("h") {
        override doGenerate(Iterable<Pair<CharSequence, CharSequence>> text) 
            '''«FOR tb: text»<b>«tb.first»</b>
            «tb.second»
            «ENDFOR»'''    
        override doString(Iterable<Pair<CharSequence, CharSequence>> text) {
            '''«FOR tb: text SEPARATOR " "»«tb.first» «tb.second»«ENDFOR»'''
        }
    }
    public static val br = new NoArgumentFunction("br") { 
        override doGenerate() '''<br/>'''
        override doString() ''''''
    }
    public static val bo = new NoArgumentFunction("bo") {
        override doGenerate() { "{" }
        override doString() { "{" }
    }    
    public static val bc = new NoArgumentFunction("bc") {
        override doGenerate() { "}" }
        override doString() { "}" }
    }    
    public static val nl = new NoArgumentFunction("nl") {
        override doGenerate() { "\n" }
        override doString() { "\n" }
    }    
    public static val tab = new NoArgumentFunction("tab") {
        override doGenerate() { "\t" }
        override doString() { "\t" }
    }   
    public static val ul = new HanashiFunction {
        override generate(Iterable<CharSequence> text) '''
        	<ul>«FOR i: text»<li>«i»</li>«ENDFOR»</ul>
        '''
        override string(Iterable<CharSequence> text) '''
        	«FOR i: text SEPARATOR "\n"»«i»«ENDFOR»
        '''
    } 
    public static val ol = new HanashiFunction {
        override generate(Iterable<CharSequence> text) '''
        	<ol>«FOR i: text»<li>«i»</li>«ENDFOR»</ol>
        '''
        override string(Iterable<CharSequence> text) '''
        	«FOR i: text SEPARATOR "\n"»«i»«ENDFOR»
        '''
    } 
    public static val em = new SurroundMarkupFunction("em", "<em>", "</em>")
    public static val pt = new SurroundFunction("pt", "[", "]")
    public static val pm = new SurroundFunction("pm", "/", "/")
    public static val gm = new SurroundFunction("gm", "⟨", "⟩")
}

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HanashiGenerator extends AbstractGenerator {
	
//	
//	dispatch def IntStream getTerminals(Terminal prod) {
//		prod.text.codePoints
//	}
//	dispatch def IntStream getTerminals(NonTerminal prod) {
//		getTerminals(prod.target.production)
//	}
//	dispatch def IntStream getTerminals(Weighted prod) {
//		IntStream.empty
//	}
//	dispatch def IntStream getTerminals(Optional prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Repeated prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Choice prod) {
//		getTerminals(prod.left).concat(getTerminals(prod.right))
//	}
//	dispatch def IntStream getTerminals(Sequence prod) {
//		prod.seq.map[p| getTerminals(p) ].stream().flatMap[s| s.boxed() ].mapToInt[v| v]
//	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val baseName = resource.URI.trimFileExtension.lastSegment
		for (article : resource.allContents.filter(Article).toIterable) 
			for (lang : article.languages) {
				val renderer = new HanashiRenderer(lang) 
				fsa.generateFile(baseName + "." + article.name + '.' + lang.name + '.html', '''
					<html>
					<head>
					<title>
					«renderer.generateRichString(article.title, false)»
					</title>
					<style>
					a:link { text-decoration: none; }
					a:hover { text-decoration: underline; }
					table.gloss { border: 0; display: inline-table; }
					.gloss-info { font-size:66%; line-height:20%; }
					</style>
					</head>
					<body>
					«FOR p: article.parts»
 					    «renderer.generatePart(p, 1)»
					«ENDFOR»
                    «FOR p: article.appendix BEFORE "<h1>Appendix</h1>"»
                        «renderer.generatePart(p, 2)»
                    «ENDFOR»
					</body>
					</html>
				''')
			}
		
	}

}
