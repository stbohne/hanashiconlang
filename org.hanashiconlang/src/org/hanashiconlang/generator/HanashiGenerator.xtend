/*
 * generated by Xtext 2.17.0
 */
package org.hanashiconlang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.hanashiconlang.hanashi.Section
import org.hanashiconlang.hanashi.FreeText
import org.hanashiconlang.hanashi.TextItem
import org.hanashiconlang.hanashi.SectionCrossRef
import org.hanashiconlang.hanashi.Lexeme
import org.hanashiconlang.hanashi.Document
import org.hanashiconlang.hanashi.LexemeCrossRef
import org.eclipse.emf.common.util.EList
import org.hanashiconlang.hanashi.GlossLexeme
import org.hanashiconlang.hanashi.Whitespace
import org.hanashiconlang.hanashi.GlossWhitespace
import org.hanashiconlang.hanashi.GlossOther
import org.hanashiconlang.hanashi.GlossSep
import org.hanashiconlang.hanashi.GlossItem
import org.hanashiconlang.hanashi.Gloss
import org.hanashiconlang.hanashi.Language
import org.hanashiconlang.hanashi.Syntax
import org.hanashiconlang.hanashi.Terminal
import java.util.HashSet
import org.hanashiconlang.hanashi.NonTerminal
import java.util.stream.IntStream
import org.hanashiconlang.hanashi.Weighted
import org.hanashiconlang.hanashi.Optional
import org.hanashiconlang.hanashi.Repeated
import org.hanashiconlang.hanashi.Choice
import org.hanashiconlang.hanashi.Sequence
import java.util.stream.Stream
import java.util.Arrays
import java.util.Dictionary
import java.util.Map

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HanashiGenerator extends AbstractGenerator {
	
	dispatch def IntStream getTerminals(Terminal prod) {
		prod.text.codePoints
	}
	dispatch def IntStream getTerminals(NonTerminal prod) {
		getTerminals(prod.target.production)
	}
	dispatch def IntStream getTerminals(Weighted prod) {
		IntStream.empty
	}
	dispatch def IntStream getTerminals(Optional prod) {
		getTerminals(prod.inner)
	}
	dispatch def IntStream getTerminals(Repeated prod) {
		getTerminals(prod.inner)
	}
	dispatch def IntStream getTerminals(Choice prod) {
		getTerminals(prod.left).concat(getTerminals(prod.right))
	}
	dispatch def IntStream getTerminals(Sequence prod) {
		prod.seq.map[p| getTerminals(p) ].stream().flatMap[s| s.boxed() ].mapToInt[v| v]
	}
	
	def title(Lexeme l, Language lang) {
		freeTexts2String(l.entries.findFirst[e| 
			e.type=="\\short" && e.language == l.language
		].texts, lang)
	}
	def shortString(Lexeme l, Language lang) {
		freeTexts2String(l.entries.findFirst[e| 
			e.type=="\\short" && e.language == lang
		].texts, lang)
	}
	def longString(Lexeme l, Language lang) {
		freeTexts2String(l.entries.findFirst[e| 
			e.type=="\\long" && e.language == lang
		].texts, lang)
	}
	def <T> strip(Iterable<T> list, Class<? extends T> clazz) {
		var list_ = list
		while (!list_.nullOrEmpty && clazz.isInstance(list_.head))
			list_ = list_.drop(1)
		while (!list_.nullOrEmpty && clazz.isInstance(list_.last))
			list_ = list_.take(list_.size - 1)
		list_
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val lang = resource.contents.filter(Document).head.languages.head
		fsa.generateFile('output.html', '''
			<html>
			<body>
			«FOR d: resource.contents.filter(Document)»
				«FOR p: d.parts»
				«generateDeclaration(p, 1, lang)»
				«ENDFOR»
			«ENDFOR»
			</body>
			</html>
		''')
		
	}
	
	def generateFreeTexts(EList<FreeText> ts, Language lang)
		'''<p>
		«FOR t: ts.strip(Whitespace)»«generateFreeText(t, lang)»«ENDFOR»
		</p>'''
	dispatch def generateFreeText(TextItem t, Language lang) {
		t.text
    }
	dispatch def generateFreeText(Whitespace ws, Language lang) {
		if (ws.texts.filter[t| t=="\n"].size >= 2) '''
			</p>
			<p>
		'''
		else
			" "
	}
	dispatch def generateFreeText(SectionCrossRef cr, Language lang) 
		'''<a href="#section$«cr.target.name»">«cr.target.title»</a>'''
	dispatch def generateFreeText(LexemeCrossRef cr, Language lang) 
		'''<a href="#lexeme$«cr.target.language.name»$«cr.target.name»">«cr.target.title(lang)»</a>'''
	dispatch def generateFreeText(Gloss g, Language lang) {
		generateGlossItems(g.items, lang)
	}
	dispatch def generateFreeText(Syntax s, Language lang) {
		""
	}
	
	def freeTexts2String(EList<FreeText> ts, Language lang) 
		'''«FOR t: ts.strip(Whitespace)»«freeText2String(t, lang)»«ENDFOR»'''
	dispatch def freeText2String(TextItem t, Language lang) 
		'''«t.text»'''
	dispatch def freeText2String(Whitespace ws, Language lang) { 
		" "
	}
	dispatch def freeText2String(SectionCrossRef cr, Language lang) 
		'''«cr.target.title»'''
	dispatch def freeText2String(LexemeCrossRef cr, Language lang) 
		'''«cr.target.title(lang)»'''
	dispatch def freeText2String(Gloss g, Language lang) 
		'''«glossItems2String(g.items, lang)»'''
	dispatch def freeText2String(Syntax s, Language lang) {
		""
	}
		
	
	def generateGlossItems(EList<GlossItem> gs, Language lang) 
		'''«FOR gi: gs.strip(GlossWhitespace)»«generateGlossItem(gi, lang)»«ENDFOR»'''
	dispatch def generateGlossItem(GlossLexeme gl, Language lang) '''
		<a href="#lexeme$«gl.lexeme.language.name»$«gl.lexeme.name»">«gl.lexeme.title(lang)»<a/>'''
	dispatch def generateGlossItem(GlossWhitespace ws, Language lang) {
		" "
	}
	dispatch def generateGlossItem(GlossOther go, Language lang) 
		'''«FOR o: go.others»«o»«ENDFOR»''' 
	dispatch def generateGlossItem(GlossSep ws, Language lang) {
		""
	}
	
	def glossItems2String(EList<GlossItem> gs, Language lang) 
		'''«FOR gi: gs.strip(GlossWhitespace)»«generateGlossItem(gi, lang)»«ENDFOR»'''
	dispatch def glossItem2String(GlossLexeme gl, Language lang) 
		'''«gl.lexeme.title(lang)»'''
	dispatch def glossItem2String(GlossWhitespace ws, Language lang) {
		" "
	}
	dispatch def glossItem2String(GlossOther go, Language lang) 
		'''«FOR o: go.others»«o»«ENDFOR»''' 
	dispatch def glossItem2String(GlossSep sep, Language lang) {
		""
	}
	
	dispatch def generateDeclaration(Section s, int depth, Language lang) '''
		<h«depth» id="section$«s.name»">«s.title»</h1>
		«generateFreeTexts(s.texts, lang)»
		«FOR p: s.parts»
		«generateDeclaration(p, depth + 1, lang)»
		«ENDFOR»
	'''
	dispatch def generateDeclaration(Lexeme l, int depth, Language lang) '''
		<h«depth» id="lexeme$«l.language.name»$«l.name»">
			«l.language.title»
			«l.title(lang)»
		</h1>
		<dl>
			«FOR e: l.entries»
			<dd>«e.language.title»</dd>
			<dt>«generateFreeTexts(e.texts, lang)»<dt/>
			«ENDFOR»
		</dl>
	'''
}
