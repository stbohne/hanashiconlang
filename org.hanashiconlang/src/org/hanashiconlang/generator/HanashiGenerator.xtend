/*
 * generated by Xtext 2.17.0
 */
package org.hanashiconlang.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.hanashiconlang.hanashi.Document
import static extension org.hanashiconlang.HanashiExtensions.*

interface HanashiFunction {
    def CharSequence generate(Iterable<CharSequence> text)
    def CharSequence string(Iterable<CharSequence> text)
}
class HanashiFunctions {
    public static val p = new HanashiFunction {
        override generate(Iterable<CharSequence> text) 
            '''<p>«text.join(" ")»</p>'''
        override string(Iterable<CharSequence> text) {
            text.join(" ")
        }
    }
    public static val br = new HanashiFunction {
        override generate(Iterable<CharSequence> text) '''<br/>'''
        override string(Iterable<CharSequence> text) ''''''
    }
    public static val bo = new HanashiFunction {
        override generate(Iterable<CharSequence> text) { "{" }
        override string(Iterable<CharSequence> text) { "{" }
    }    
    public static val bc = new HanashiFunction {
        override generate(Iterable<CharSequence> text) { "}" }
        override string(Iterable<CharSequence> text) { "}" }
    }    
    public static val nl = new HanashiFunction {
        override generate(Iterable<CharSequence> text) { "\n" }
        override string(Iterable<CharSequence> text) { "\n" }
    }    
    public static val tab = new HanashiFunction {
        override generate(Iterable<CharSequence> text) { "\t" }
        override string(Iterable<CharSequence> text) { "\t" }
    }    
}

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HanashiGenerator extends AbstractGenerator {
	
//	
//	dispatch def IntStream getTerminals(Terminal prod) {
//		prod.text.codePoints
//	}
//	dispatch def IntStream getTerminals(NonTerminal prod) {
//		getTerminals(prod.target.production)
//	}
//	dispatch def IntStream getTerminals(Weighted prod) {
//		IntStream.empty
//	}
//	dispatch def IntStream getTerminals(Optional prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Repeated prod) {
//		getTerminals(prod.inner)
//	}
//	dispatch def IntStream getTerminals(Choice prod) {
//		getTerminals(prod.left).concat(getTerminals(prod.right))
//	}
//	dispatch def IntStream getTerminals(Sequence prod) {
//		prod.seq.map[p| getTerminals(p) ].stream().flatMap[s| s.boxed() ].mapToInt[v| v]
//	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val lang = (resource.contents.get(0) as Document).language
		val baseName = resource.URI.trimFileExtension.lastSegment
		val renderer = new HanashiRenderer(lang) 
		fsa.generateFile(baseName + '.html', '''
			<html>
			<head>
			<style>
			a:link { text-decoration: none; }
			a:hover { text-decoration: underline; }
			table.gloss { border: 0; }
			.gloss-info { font-size:66%; line-height:20%; }
			</style>
			</head>
			<body>
			«FOR d: resource.contents.filter(Document)»
				«FOR p: d.parts»
				«renderer.generateDeclaration(p, 1)»
				«ENDFOR»
			«ENDFOR»
			</body>
			</html>
		''')
		
	}

}
